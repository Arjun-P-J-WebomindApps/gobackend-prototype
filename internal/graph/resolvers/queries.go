package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"fmt"

	"github.com/Arjun-P-J-WebomindApps/gobackend-prototype/internal/db/models"
	"github.com/Arjun-P-J-WebomindApps/gobackend-prototype/internal/graph/generated"
	"github.com/Arjun-P-J-WebomindApps/gobackend-prototype/internal/graph/model"
	"github.com/google/uuid"
)

// GetUserByID is the resolver for the getUserById field.
func (r *queryResolver) GetUserByID(ctx context.Context, id uuid.UUID) (*models.User, error) {
	panic(fmt.Errorf("not implemented: GetUserByID - getUserById"))
}

// GetAllUsers is the resolver for the getAllUsers field.
func (r *queryResolver) GetAllUsers(ctx context.Context) ([]*models.User, error) {
	users, err := r.DB.Queries.GetAllUsers(ctx)

	if err != nil {
		return nil, fmt.Errorf("failed to fetch users: %s", err.Error())
	}

	userPtrs := make([]*models.User, 0, len(users))

	for i := range users {
		user := users[i]
		userPtrs = append(userPtrs, &user)
	}

	return userPtrs, nil
}

// GetLatestOtp is the resolver for the getLatestOTP field.
func (r *queryResolver) GetLatestOtp(ctx context.Context, userID uuid.UUID) (*models.UserOtp, error) {
	otp, err := r.DB.Queries.GetLatestOTPFromUser(ctx, userID)

	if err != nil {
		return nil, fmt.Errorf("failed to fetch otp")
	}

	return &otp, nil
}

// GetSessionByUserID is the resolver for the getSessionByUserId field.
func (r *queryResolver) GetSessionByUserID(ctx context.Context, userID uuid.UUID) (*models.UserSession, error) {
	session, err := r.DB.Queries.GetUserSessionByUserId(ctx, userID)

	if err != nil {
		return nil, fmt.Errorf("faailed to get session %s", err.Error())
	}

	return &session, nil
}

// GetSessionStatus is the resolver for the getSessionStatus field.
func (r *queryResolver) GetSessionStatus(ctx context.Context, sessionID uuid.UUID) (*model.SessionStatus, error) {
	session, err := r.DB.Queries.GetUserSessionById(ctx, sessionID)

	if err != nil {
		return nil, fmt.Errorf("failed to get session %s", err.Error())
	}

	return &model.SessionStatus{
		Valid: session.RevokedAt.Valid,
	}, nil
}

// GetAllCompany is the resolver for the getAllCompany field.
func (r *queryResolver) GetAllCompany(ctx context.Context) ([]*models.Company, error) {
	companies, err := r.DB.Queries.GetAllCompanies(ctx)

	if err != nil {
		return nil, fmt.Errorf("couldt fetch companies")
	}

	companiesPtr := make([]*models.Company, 0, len(companies))

	for i, _ := range companies {
		company := companies[i]
		companiesPtr = append(companiesPtr, &company)
	}

	return companiesPtr, nil
}

// GetCompanyByName is the resolver for the getCompanyByName field.
func (r *queryResolver) GetCompanyByName(ctx context.Context, name string) (*models.Company, error) {
	company, err := r.DB.Queries.GetCompanyByName(ctx, name)

	if err != nil {
		return nil, fmt.Errorf("couldnt fetch the company %s", err.Error())
	}

	return &company, nil
}

// GetAllCustomers is the resolver for the getAllCustomers field.
func (r *queryResolver) GetAllCustomers(ctx context.Context) ([]*models.Customer, error) {
	customers, err := r.DB.Queries.GetAllCustomers(ctx)

	if err != nil {
		return nil, fmt.Errorf("couldnt get all customers")
	}

	customersPtr := make([]*models.Customer, 0, len(customers))

	for i := range customers {
		customer := customers[i]
		customersPtr = append(customersPtr, &customer)
	}

	return customersPtr, nil
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }

package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"log"
	"time"

	"github.com/Arjun-P-J-WebomindApps/gobackend-prototype/internal/db/models"
	generated1 "github.com/Arjun-P-J-WebomindApps/gobackend-prototype/internal/graph/generated"
	"github.com/Arjun-P-J-WebomindApps/gobackend-prototype/internal/graph/model"
	"github.com/Arjun-P-J-WebomindApps/gobackend-prototype/internal/utils"
	"github.com/google/uuid"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*models.User, error) {
	id := uuid.New()

	user, err := r.DB.Queries.CreateUser(ctx, models.CreateUserParams{
		ID:          id,
		Name:        input.Name,
		Username:    input.Username,
		Email:       input.Email,
		Password:    input.Password, //hash
		Mobile:      input.Mobile,
		Role:        input.Role,
		IsActive:    true,
		MaxSessions: 3,
		DeletedAt:   sql.NullTime{},
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	})

	if err != nil {
		log.Println("Couldn't add user " + err.Error())
		fmt.Println("error for ", input.Name, input.Username)
		return nil, fmt.Errorf("could not create user: %w", err)
	}

	return &user, nil
}

// CreateUserOtp is the resolver for the createUserOTP field.
func (r *mutationResolver) CreateUserOtp(ctx context.Context, input model.CreateUserOTPInput) (*models.UserOtp, error) {
	// Check for existing OTP
	exisitingOTP, err := r.DB.Queries.GetLatestOTPFromUser(ctx, input.UserID)

	if err != nil && err != sql.ErrNoRows {
		return nil, fmt.Errorf("failed to get otp")
	}

	if err == nil && time.Since(exisitingOTP.CreatedAt) < time.Second*5 {
		return nil, fmt.Errorf("please wait a few seconds before requesting a new OTP")
	}

	// If existing OTP is found, delete it
	if err == nil && exisitingOTP.ID != 0 {

		// Reuse existing valid OTP if available (i dont think we need to do this)
		// if !exisitingOTP.IsUsed && time.Now().Before(exisitingOTP.ExpiresAt) {
		// 	return &exisitingOTP, nil
		// }

		errDeleted := r.DB.Queries.DeleteUserOTPByUserId(ctx, input.UserID)

		if errDeleted != nil {
			return nil, fmt.Errorf("deletion error %s", errDeleted.Error())
		}
	}

	code, errCode := utils.GenerateNumericOTP(6)

	if errCode != nil {
		return nil, fmt.Errorf("OTP generation issue %s", errCode.Error())
	}
	// Generate OTP
	otp, err := r.DB.Queries.CreateOTP(
		ctx,
		models.CreateOTPParams{
			UserID:    input.UserID,
			OtpCode:   fmt.Sprint(code),
			IsUsed:    false,
			CreatedAt: time.Now(),
			ExpiresAt: time.Now().Add(time.Minute * 5),
		})

	if err != nil {
		return nil, fmt.Errorf("otp generation failed %s", err.Error())
	}

	return &otp, nil
}

// CreateUserSession is the resolver for the createUserSession field.
func (r *mutationResolver) CreateUserSession(ctx context.Context, input model.CreateUserSessionInput) (*models.UserSession, error) {
	_, err := r.DB.Queries.GetUserById(ctx, input.UserID)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, fmt.Errorf("no user found with id: %s", input.UserID)
		}
		return nil, fmt.Errorf("failed to fetch user: %w", err)
	}

	uuid := uuid.New()

	session, err := r.DB.Queries.CreateUserSession(ctx, models.CreateUserSessionParams{
		SessionID: uuid,
		UserID:    input.UserID,
		CreatedAt: time.Now(),
		ExpiresAt: time.Now().Add(time.Minute * 5),
		IpAddress: input.IPAddress,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to create a session %s", err.Error())
	}

	return &session, nil
}

// CreateRefreshToken is the resolver for the createRefreshToken field.
func (r *mutationResolver) CreateRefreshToken(ctx context.Context, input model.CreateRefreshTokenInput) (*models.RefreshToken, error) {
	//Validate session
	session, err := r.DB.Queries.GetUserSessionById(ctx, *input.SessionID)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, fmt.Errorf("no session found %s", err.Error())
		}
		return nil, fmt.Errorf("failed to fetch session id %s", err.Error())
	}

	if session.ExpiresAt.Before(time.Now()) {
		return nil, fmt.Errorf("cannot create refresh token : session expired ")
	}

	//Check for existing valid refresh token
	existingToken, err := r.DB.Queries.GetRefreshToken(ctx, session.SessionID)

	if err == nil {
		if !existingToken.RevokedAt.Valid && existingToken.ExpiresAt.After(time.Now()) {
			return nil, fmt.Errorf("a valid refresh token exists")
		}
	} else if errors.Is(err, sql.ErrNoRows) {
		return nil, fmt.Errorf(" fialed to check existing refresh token %s", err.Error())
	}

	sessionToken, err := utils.GenerateSecureToken(64)

	if err != nil {
		return nil, fmt.Errorf("filed to generate session token %w", err.Error())
	}

	refreshTokenId := uuid.New()

	token, err := r.DB.Queries.CreateRefreshToken(ctx, models.CreateRefreshTokenParams{
		ID:        refreshTokenId,
		UserID:    input.UserID,
		SessionID: *input.SessionID,
		TokenHash: sessionToken,
		CreatedAt: time.Now(),
		ExpiresAt: time.Now().Add(time.Minute * 5),
		RevokedAt: sql.NullTime{Valid: false},
	})

	if err != nil {
		return nil, fmt.Errorf("couldnt create refresh token %s", err.Error())
	}

	return &token, nil
}

// RevokeRefreshToken is the resolver for the revokeRefreshToken field.
func (r *mutationResolver) RevokeRefreshToken(ctx context.Context, tokenID uuid.UUID) (bool, error) {
	err := r.DB.Queries.RevokeRefreshToken(ctx, tokenID.String())

	if err != nil {
		return false, fmt.Errorf("failed to revoke token %s", err.Error())
	}

	return true, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	//1. Check if the user exits
	user, err := r.DB.Queries.GetUserByEmail(ctx, input.Email)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("invalid email or password")
		}

		return nil, fmt.Errorf("failed to fetch user %s", err.Error())
	}

	//2. Check if the password match
	hashErr := utils.CheckPassword(input.Password, user.Password)

	if hashErr != nil {
		return nil, fmt.Errorf("invalid password")
	}

	//Assume session id to be created later after verify otp
	return &model.AuthPayload{
		User: &user,
	}, nil
}

// VerifyOtp is the resolver for the verifyOTP field.
func (r *mutationResolver) VerifyOtp(ctx context.Context, input model.VerifyOTPInput) (*model.AuthPayload, error) {
	otp, err := r.DB.Queries.GetLatestOTPFromUser(ctx, input.UserID)

	if err != nil || input.OtpCode != otp.OtpCode {
		return nil, fmt.Errorf("invalid otp or expired")
	}

	if time.Now().After(otp.ExpiresAt) || otp.IsUsed {
		return nil, fmt.Errorf("OTP is expired or already used")
	}

	markErr := r.DB.Queries.MarkOTPAsUsed(ctx, otp.UserID)

	if markErr != nil {
		return nil, fmt.Errorf("failed to mark otp as used %s", markErr.Error())
	}

	userId := otp.UserID.String()

	return &model.AuthPayload{
		UserID: &userId,
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input model.RefreshTokenInput) (*model.AuthPayload, error) {
	refreshToken, err := r.DB.Queries.GetRefreshToken(ctx, uuid.MustParse(input.SessionID))

	if err != nil {
		return nil, fmt.Errorf("couldn't get refresh token")
	}

	if refreshToken.RevokedAt.Valid || refreshToken.ExpiresAt.Before(time.Now()) {
		return nil, fmt.Errorf("token is invalid or expired")
	}

	errToken := r.DB.Queries.RevokeRefreshToken(ctx, refreshToken.TokenHash)

	if errToken != nil {
		return nil, fmt.Errorf("failed to revoke refresh token")
	}

	userIdStr := refreshToken.UserID.String()

	return &model.AuthPayload{
		UserID: &userIdStr,
	}, nil
}

// CreateCompany is the resolver for the createCompany field.
func (r *mutationResolver) CreateCompany(ctx context.Context, input model.CreateCompanyInput) (*models.Company, error) {
	panic(fmt.Errorf("not implemented: CreateCompany - createCompany"))
}

// CreateModel is the resolver for the createModel field.
func (r *mutationResolver) CreateModel(ctx context.Context, input model.CreateModelInput) (*models.Model, error) {
	panic(fmt.Errorf("not implemented: CreateModel - createModel"))
}

// CreateModelVariant is the resolver for the createModelVariant field.
func (r *mutationResolver) CreateModelVariant(ctx context.Context, input model.CreateModelVariantInput) (*models.ModelVariant, error) {
	panic(fmt.Errorf("not implemented: CreateModelVariant - createModelVariant"))
}

// CreateBrand is the resolver for the createBrand field.
func (r *mutationResolver) CreateBrand(ctx context.Context, input model.CreateBrandInput) (*models.Brand, error) {
	panic(fmt.Errorf("not implemented: CreateBrand - createBrand"))
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input model.CreateCategoryInput) (*models.Category, error) {
	panic(fmt.Errorf("not implemented: CreateCategory - createCategory"))
}

// CreateProductPart is the resolver for the createProductPart field.
func (r *mutationResolver) CreateProductPart(ctx context.Context, input model.CreateProductPartInput) (*models.ProductPart, error) {
	panic(fmt.Errorf("not implemented: CreateProductPart - createProductPart"))
}

// GetUserByID is the resolver for the getUserById field.
func (r *queryResolver) GetUserByID(ctx context.Context, id uuid.UUID) (*models.User, error) {
	panic(fmt.Errorf("not implemented: GetUserByID - getUserById"))
}

// GetAllUsers is the resolver for the getAllUsers field.
func (r *queryResolver) GetAllUsers(ctx context.Context) ([]*models.User, error) {
	users, err := r.DB.Queries.GetAllUsers(ctx)

	if err != nil {
		return nil, fmt.Errorf("failed to fetch users: %s", err.Error())
	}

	userPtrs := make([]*models.User, 0, len(users))

	for i := range users {
		user := users[i]
		userPtrs = append(userPtrs, &user)
	}

	return userPtrs, nil
}

// GetLatestOtp is the resolver for the getLatestOTP field.
func (r *queryResolver) GetLatestOtp(ctx context.Context, userID uuid.UUID) (*models.UserOtp, error) {
	otp, err := r.DB.Queries.GetLatestOTPFromUser(ctx, userID)

	if err != nil {
		return nil, fmt.Errorf("failed to fetch otp")
	}

	return &otp, nil
}

// GetSessionByUserID is the resolver for the getSessionByUserId field.
func (r *queryResolver) GetSessionByUserID(ctx context.Context, userID uuid.UUID) (*models.UserSession, error) {
	session, err := r.DB.Queries.GetUserSessionByUserId(ctx, userID)

	if err != nil {
		return nil, fmt.Errorf("faailed to get session %s", err.Error())
	}

	return &session, nil
}

// GetSessionStatus is the resolver for the getSessionStatus field.
func (r *queryResolver) GetSessionStatus(ctx context.Context, sessionID uuid.UUID) (*model.SessionStatus, error) {
	session, err := r.DB.Queries.GetUserSessionById(ctx, sessionID)

	if err != nil {
		return nil, fmt.Errorf("failed to get session %s", err.Error())
	}

	return &model.SessionStatus{
		Valid: session.RevokedAt.Valid,
	}, nil
}

// Mutation returns generated1.MutationResolver implementation.
func (r *Resolver) Mutation() generated1.MutationResolver { return &mutationResolver{r} }

// Query returns generated1.QueryResolver implementation.
func (r *Resolver) Query() generated1.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

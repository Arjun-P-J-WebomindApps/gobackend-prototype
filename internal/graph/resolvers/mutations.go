package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"log"
	"time"

	"github.com/Arjun-P-J-WebomindApps/gobackend-prototype/internal/db/models"
	"github.com/Arjun-P-J-WebomindApps/gobackend-prototype/internal/graph/generated"
	"github.com/Arjun-P-J-WebomindApps/gobackend-prototype/internal/graph/model"
	"github.com/Arjun-P-J-WebomindApps/gobackend-prototype/internal/utils"
	"github.com/google/uuid"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*models.User, error) {
	id := uuid.New()

	user, err := r.DB.Queries.CreateUser(ctx, models.CreateUserParams{
		ID:          id,
		Name:        input.Name,
		Username:    input.Username,
		Email:       input.Email,
		Password:    input.Password, //hash
		Mobile:      input.Mobile,
		Role:        input.Role,
		IsActive:    true,
		MaxSessions: 3,
		DeletedAt:   sql.NullTime{},
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	})

	if err != nil {
		log.Println("Couldn't add user " + err.Error())
		fmt.Println("error for ", input.Name, input.Username)
		return nil, fmt.Errorf("could not create user: %w", err)
	}

	return &user, nil
}

// CreateUserOtp is the resolver for the createUserOTP field.
func (r *mutationResolver) CreateUserOtp(ctx context.Context, input model.CreateUserOTPInput) (*models.UserOtp, error) {
	// Check for existing OTP
	exisitingOTP, err := r.DB.Queries.GetLatestOTPFromUser(ctx, input.UserID)

	if err != nil && err != sql.ErrNoRows {
		return nil, fmt.Errorf("failed to get otp")
	}

	if err == nil && time.Since(exisitingOTP.CreatedAt) < time.Second*5 {
		return nil, fmt.Errorf("please wait a few seconds before requesting a new OTP")
	}

	// If existing OTP is found, delete it
	if err == nil && exisitingOTP.ID != 0 {

		// Reuse existing valid OTP if available (i dont think we need to do this)
		// if !exisitingOTP.IsUsed && time.Now().Before(exisitingOTP.ExpiresAt) {
		// 	return &exisitingOTP, nil
		// }

		errDeleted := r.DB.Queries.DeleteUserOTPByUserId(ctx, input.UserID)

		if errDeleted != nil {
			return nil, fmt.Errorf("deletion error %s", errDeleted.Error())
		}
	}

	code, errCode := utils.GenerateNumericOTP(6)

	if errCode != nil {
		return nil, fmt.Errorf("OTP generation issue %s", errCode.Error())
	}
	// Generate OTP
	otp, err := r.DB.Queries.CreateOTP(
		ctx,
		models.CreateOTPParams{
			UserID:    input.UserID,
			OtpCode:   fmt.Sprint(code),
			IsUsed:    false,
			CreatedAt: time.Now(),
			ExpiresAt: time.Now().Add(time.Minute * 5),
		})

	if err != nil {
		return nil, fmt.Errorf("otp generation failed %s", err.Error())
	}

	return &otp, nil
}

// CreateUserSession is the resolver for the createUserSession field.
func (r *mutationResolver) CreateUserSession(ctx context.Context, input model.CreateUserSessionInput) (*models.UserSession, error) {
	_, err := r.DB.Queries.GetUserById(ctx, input.UserID)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, fmt.Errorf("no user found with id: %s", input.UserID)
		}
		return nil, fmt.Errorf("failed to fetch user: %w", err)
	}

	uuid := uuid.New()

	session, err := r.DB.Queries.CreateUserSession(ctx, models.CreateUserSessionParams{
		SessionID: uuid,
		UserID:    input.UserID,
		CreatedAt: time.Now(),
		ExpiresAt: time.Now().Add(time.Minute * 5),
		IpAddress: input.IPAddress,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to create a session %s", err.Error())
	}

	return &session, nil
}

// CreateRefreshToken is the resolver for the createRefreshToken field.
func (r *mutationResolver) CreateRefreshToken(ctx context.Context, input model.CreateRefreshTokenInput) (*models.RefreshToken, error) {
	//Validate session
	session, err := r.DB.Queries.GetUserSessionById(ctx, *input.SessionID)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, fmt.Errorf("no session found %s", err.Error())
		}
		return nil, fmt.Errorf("failed to fetch session id %s", err.Error())
	}

	if session.ExpiresAt.Before(time.Now()) {
		return nil, fmt.Errorf("cannot create refresh token : session expired ")
	}

	//Check for existing valid refresh token
	existingToken, err := r.DB.Queries.GetRefreshToken(ctx, session.SessionID)

	if err == nil {
		if !existingToken.RevokedAt.Valid && existingToken.ExpiresAt.After(time.Now()) {
			return nil, fmt.Errorf("a valid refresh token exists")
		}
	} else if errors.Is(err, sql.ErrNoRows) {
		return nil, fmt.Errorf(" fialed to check existing refresh token %s", err.Error())
	}

	sessionToken, err := utils.GenerateSecureToken(64)

	if err != nil {
		return nil, fmt.Errorf("filed to generate session token %w", err.Error())
	}

	refreshTokenId := uuid.New()

	token, err := r.DB.Queries.CreateRefreshToken(ctx, models.CreateRefreshTokenParams{
		ID:        refreshTokenId,
		UserID:    input.UserID,
		SessionID: *input.SessionID,
		TokenHash: sessionToken,
		CreatedAt: time.Now(),
		ExpiresAt: time.Now().Add(time.Minute * 5),
		RevokedAt: sql.NullTime{Valid: false},
	})

	if err != nil {
		return nil, fmt.Errorf("couldnt create refresh token %s", err.Error())
	}

	return &token, nil
}

// RevokeRefreshToken is the resolver for the revokeRefreshToken field.
func (r *mutationResolver) RevokeRefreshToken(ctx context.Context, tokenID uuid.UUID) (bool, error) {
	err := r.DB.Queries.RevokeRefreshToken(ctx, tokenID.String())

	if err != nil {
		return false, fmt.Errorf("failed to revoke token %s", err.Error())
	}

	return true, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	//1. Check if the user exits
	user, err := r.DB.Queries.GetUserByEmail(ctx, input.Email)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("invalid email or password")
		}

		return nil, fmt.Errorf("failed to fetch user %s", err.Error())
	}

	//2. Check if the password match
	hashErr := utils.CheckPassword(input.Password, user.Password)

	if hashErr != nil {
		return nil, fmt.Errorf("invalid password")
	}

	//Assume session id to be created later after verify otp
	return &model.AuthPayload{
		User: &user,
	}, nil
}

// VerifyOtp is the resolver for the verifyOTP field.
func (r *mutationResolver) VerifyOtp(ctx context.Context, input model.VerifyOTPInput) (*model.AuthPayload, error) {
	otp, err := r.DB.Queries.GetLatestOTPFromUser(ctx, input.UserID)

	if err != nil || input.OtpCode != otp.OtpCode {
		return nil, fmt.Errorf("invalid otp or expired")
	}

	if time.Now().After(otp.ExpiresAt) || otp.IsUsed {
		return nil, fmt.Errorf("OTP is expired or already used")
	}

	markErr := r.DB.Queries.MarkOTPAsUsed(ctx, otp.UserID)

	if markErr != nil {
		return nil, fmt.Errorf("failed to mark otp as used %s", markErr.Error())
	}

	userId := otp.UserID.String()

	return &model.AuthPayload{
		UserID: &userId,
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input model.RefreshTokenInput) (*model.AuthPayload, error) {
	refreshToken, err := r.DB.Queries.GetRefreshToken(ctx, uuid.MustParse(input.SessionID))

	if err != nil {
		return nil, fmt.Errorf("couldn't get refresh token")
	}

	if refreshToken.RevokedAt.Valid || refreshToken.ExpiresAt.Before(time.Now()) {
		return nil, fmt.Errorf("token is invalid or expired")
	}

	errToken := r.DB.Queries.RevokeRefreshToken(ctx, refreshToken.TokenHash)

	if errToken != nil {
		return nil, fmt.Errorf("failed to revoke refresh token")
	}

	userIdStr := refreshToken.UserID.String()

	return &model.AuthPayload{
		UserID: &userIdStr,
	}, nil
}

// CreateCompany is the resolver for the createCompany field.
func (r *mutationResolver) CreateCompany(ctx context.Context, input model.CreateCompanyInput) (*models.Company, error) {

	uuid := uuid.New()
	company, err := r.DB.Queries.CreateCompanies(ctx, models.CreateCompaniesParams{
		ID:     uuid,
		Name:   input.Name,
		Status: input.Status,
	})

	log.Println("Creating user")

	if err != nil {
		return nil, fmt.Errorf("couldnt create company : %s", err.Error())
	}

	return &company, nil
}

// CreateModel is the resolver for the createModel field.
func (r *mutationResolver) CreateModel(ctx context.Context, input model.CreateModelInput) (*models.Model, error) {
	company, err := r.DB.Queries.GetCompanyByName(ctx, input.CompanyName)

	if err != nil {
		return nil, fmt.Errorf("invalid company name")
	}

	uuid := uuid.New()

	model, err := r.DB.Queries.CreateModel(ctx, models.CreateModelParams{
		ID:        uuid,
		Name:      input.Name,
		CompanyID: company.ID,
	})

	if err != nil {
		return nil, fmt.Errorf("couldn't create model %s", err.Error())
	}

	return &model, nil
}

// CreateModelVariant is the resolver for the createModelVariant field.
func (r *mutationResolver) CreateModelVariant(ctx context.Context, input model.CreateModelVariantInput) (*models.ModelVariant, error) {
	model, err := r.DB.Queries.GetModelByName(ctx, input.ModelName)

	if err != nil {
		return nil, fmt.Errorf("invliad model name %s", err.Error())
	}

	uuid := uuid.New()

	modelVariant, err := r.DB.Queries.CreateModelVariant(ctx, models.CreateModelVariantParams{
		ID:         uuid,
		ModelID:    model.ID,
		ModelType:  utils.ToNullString(input.ModelType),
		ModelImage: utils.ToNullString(input.ModelImage),
	})

	if err != nil {
		return nil, fmt.Errorf("couldnt create model variant %s", err.Error())
	}

	return &modelVariant, nil
}

// CreateBrand is the resolver for the createBrand field.
func (r *mutationResolver) CreateBrand(ctx context.Context, input model.CreateBrandInput) (*models.Brand, error) {

	uuid := uuid.New()

	brand, err := r.DB.Queries.CreateBrand(ctx, models.CreateBrandParams{
		ID:   uuid,
		Name: input.Name,
	})

	if err != nil {
		return nil, fmt.Errorf("brand could not be added %s", err.Error())
	}

	return &brand, nil

}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input model.CreateCategoryInput) (*models.Category, error) {
	uuid := uuid.New()
	category, err := r.DB.Queries.CreateCategories(ctx, models.CreateCategoriesParams{
		ID:    uuid,
		Name:  input.Name,
		Image: utils.ToNullString(input.Image),
	})
	if err != nil {
		return nil, fmt.Errorf("couldnt create category %s", err.Error())
	}

	return &category, nil
}

// CreateProductPart is the resolver for the createProductPart field.
func (r *mutationResolver) CreateProductPart(ctx context.Context, input model.CreateProductPartInput) (*models.ProductPart, error) {
	company, err := r.DB.Queries.GetCompanyByName(ctx, input.CompanyName)
	if err != nil {
		return nil, fmt.Errorf("couldnt get company")
	}

	model, err := r.DB.Queries.GetModelByName(ctx, input.ModelName)

	if err != nil {
		return nil, fmt.Errorf("couldnt get model")
	}

	brand, err := r.DB.Queries.GetBrandByName(ctx, input.BrandName)

	if err != nil {
		return nil, fmt.Errorf("couldn't get brand")
	}

	category, err := r.DB.Queries.GetCategoriesByName(ctx, input.CategoryName)

	if err != nil {
		return nil, fmt.Errorf("couldnt get category")
	}

	uuid := uuid.New()

	productPart, err := r.DB.Queries.CreateProductParts(ctx, models.CreateProductPartsParams{
		ID:         uuid,
		CompanyID:  company.ID,
		ModelID:    model.ID,
		BrandID:    brand.ID,
		PartNo:     input.PartNo,
		IsActive:   sql.NullBool{Bool: input.IsActive, Valid: true},
		CategoryID: category.ID,
		CreatedAt:  time.Now(),
		UpdatedAt:  time.Now(),
	})

	if err != nil {
		return nil, fmt.Errorf("couldnt create new part %s", err.Error())
	}

	return &productPart, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }

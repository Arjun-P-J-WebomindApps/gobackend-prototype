package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/Arjun-P-J-WebomindApps/gobackend-prototype/internal/db/models"
	"github.com/Arjun-P-J-WebomindApps/gobackend-prototype/internal/graph"
	"github.com/Arjun-P-J-WebomindApps/gobackend-prototype/internal/graph/model"
	"github.com/Arjun-P-J-WebomindApps/gobackend-prototype/internal/utils"
	"github.com/google/uuid"
)

// CreateUserOtp is the resolver for the createUserOTP field.
func (r *mutationResolver) CreateUserOtp(ctx context.Context, input model.CreateUserOTPInput) (*models.UserOtp, error) {
	// Check for existing OTP
	exisitingOTP, err := r.DB.Queries.GetLatestOTPFromUser(ctx, input.UserID)

	if err != nil && err != sql.ErrNoRows {
		return nil, fmt.Errorf("failed to get otp")
	}

	if err == nil && time.Since(exisitingOTP.CreatedAt) < time.Second*5 {
		return nil, fmt.Errorf("please wait a few seconds before requesting a new OTP")
	}

	// If existing OTP is found, delete it
	if err == nil && exisitingOTP.ID != 0 {

		// Reuse existing valid OTP if available (i dont think we need to do this)
		// if !exisitingOTP.IsUsed && time.Now().Before(exisitingOTP.ExpiresAt) {
		// 	return &exisitingOTP, nil
		// }

		errDeleted := r.DB.Queries.DeleteUserOTPByUserId(ctx, input.UserID)

		if errDeleted != nil {
			return nil, fmt.Errorf("deletion error %s", errDeleted.Error())
		}
	}

	code, errCode := utils.GenerateNumericOTP(6)

	if errCode != nil {
		return nil, fmt.Errorf("OTP generation issue %s", errCode.Error())
	}
	// Generate OTP
	otp, err := r.DB.Queries.CreateOTP(
		ctx,
		models.CreateOTPParams{
			UserID:    input.UserID,
			OtpCode:   fmt.Sprint(code),
			IsUsed:    false,
			CreatedAt: time.Now(),
			ExpiresAt: time.Now().Add(time.Minute * 5),
		})

	if err != nil {

		return nil, fmt.Errorf("otp generation failed %s", err.Error())
	}

	return &otp, nil
}

// ID is the resolver for the id field.
func (r *userOTPResolver) ID(ctx context.Context, obj *models.UserOtp) (uuid.UUID, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// IsUsed is the resolver for the isUsed field.
func (r *userOTPResolver) IsUsed(ctx context.Context, obj *models.UserOtp) (bool, error) {
	panic(fmt.Errorf("not implemented: IsUsed - isUsed"))
}

// CreatedAt is the resolver for the createdAt field.
func (r *userOTPResolver) CreatedAt(ctx context.Context, obj *models.UserOtp) (*time.Time, error) {
	panic(fmt.Errorf("not implemented: CreatedAt - createdAt"))
}

// UserOTP returns UserOTPResolver implementation.
func (r *Resolver) UserOTP() graph.UserOTPResolver { return &userOTPResolver{r} }

type userOTPResolver struct{ *Resolver }

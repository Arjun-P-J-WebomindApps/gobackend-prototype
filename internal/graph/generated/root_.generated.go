// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/Arjun-P-J-WebomindApps/gobackend-prototype/internal/graph/model"
	"github.com/google/uuid"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	RefreshToken() RefreshTokenResolver
	User() UserResolver
	UserOTP() UserOTPResolver
	UserSession() UserSessionResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AuthPayload struct {
		AccessToken  func(childComplexity int) int
		RefreshToken func(childComplexity int) int
		SessionID    func(childComplexity int) int
		User         func(childComplexity int) int
		UserID       func(childComplexity int) int
	}

	Mutation struct {
		CreateRefreshToken func(childComplexity int, input model.CreateRefreshTokenInput) int
		CreateUser         func(childComplexity int, input model.CreateUserInput) int
		CreateUserOtp      func(childComplexity int, input model.CreateUserOTPInput) int
		CreateUserSession  func(childComplexity int, input model.CreateUserSessionInput) int
		Login              func(childComplexity int, input model.LoginInput) int
		RefreshToken       func(childComplexity int, input model.RefreshTokenInput) int
		RevokeRefreshToken func(childComplexity int, tokenID uuid.UUID) int
		VerifyOtp          func(childComplexity int, input model.VerifyOTPInput) int
	}

	Query struct {
		GetAllUsers        func(childComplexity int) int
		GetLatestOtp       func(childComplexity int, userID uuid.UUID) int
		GetSessionByUserID func(childComplexity int, userID uuid.UUID) int
		GetSessionStatus   func(childComplexity int, sessionID uuid.UUID) int
		GetUserByID        func(childComplexity int, id uuid.UUID) int
	}

	RefreshToken struct {
		CreatedAt  func(childComplexity int) int
		ExpiresAt  func(childComplexity int) int
		ID         func(childComplexity int) int
		IPAddress  func(childComplexity int) int
		ReplacedBy func(childComplexity int) int
		RevokedAt  func(childComplexity int) int
		SessionID  func(childComplexity int) int
		TokenHash  func(childComplexity int) int
		UserAgent  func(childComplexity int) int
		UserID     func(childComplexity int) int
	}

	SessionStatus struct {
		User  func(childComplexity int) int
		Valid func(childComplexity int) int
	}

	User struct {
		CreatedAt func(childComplexity int) int
		DeletedAt func(childComplexity int) int
		Email     func(childComplexity int) int
		ID        func(childComplexity int) int
		IsActive  func(childComplexity int) int
		Mobile    func(childComplexity int) int
		Name      func(childComplexity int) int
		Password  func(childComplexity int) int
		Role      func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		Username  func(childComplexity int) int
	}

	UserOTP struct {
		CreatedAt func(childComplexity int) int
		ExpiresAt func(childComplexity int) int
		ID        func(childComplexity int) int
		IsUsed    func(childComplexity int) int
		OtpCode   func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	UserSession struct {
		CreatedAt func(childComplexity int) int
		ExpiresAt func(childComplexity int) int
		IpAddress func(childComplexity int) int
		RevokedAt func(childComplexity int) int
		SessionID func(childComplexity int) int
		UserAgent func(childComplexity int) int
		UserID    func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AuthPayload.accessToken":
		if e.complexity.AuthPayload.AccessToken == nil {
			break
		}

		return e.complexity.AuthPayload.AccessToken(childComplexity), true

	case "AuthPayload.refreshToken":
		if e.complexity.AuthPayload.RefreshToken == nil {
			break
		}

		return e.complexity.AuthPayload.RefreshToken(childComplexity), true

	case "AuthPayload.sessionId":
		if e.complexity.AuthPayload.SessionID == nil {
			break
		}

		return e.complexity.AuthPayload.SessionID(childComplexity), true

	case "AuthPayload.user":
		if e.complexity.AuthPayload.User == nil {
			break
		}

		return e.complexity.AuthPayload.User(childComplexity), true

	case "AuthPayload.userId":
		if e.complexity.AuthPayload.UserID == nil {
			break
		}

		return e.complexity.AuthPayload.UserID(childComplexity), true

	case "Mutation.createRefreshToken":
		if e.complexity.Mutation.CreateRefreshToken == nil {
			break
		}

		args, err := ec.field_Mutation_createRefreshToken_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateRefreshToken(childComplexity, args["input"].(model.CreateRefreshTokenInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(model.CreateUserInput)), true

	case "Mutation.createUserOTP":
		if e.complexity.Mutation.CreateUserOtp == nil {
			break
		}

		args, err := ec.field_Mutation_createUserOTP_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUserOtp(childComplexity, args["input"].(model.CreateUserOTPInput)), true

	case "Mutation.createUserSession":
		if e.complexity.Mutation.CreateUserSession == nil {
			break
		}

		args, err := ec.field_Mutation_createUserSession_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUserSession(childComplexity, args["input"].(model.CreateUserSessionInput)), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["input"].(model.LoginInput)), true

	case "Mutation.refreshToken":
		if e.complexity.Mutation.RefreshToken == nil {
			break
		}

		args, err := ec.field_Mutation_refreshToken_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RefreshToken(childComplexity, args["input"].(model.RefreshTokenInput)), true

	case "Mutation.revokeRefreshToken":
		if e.complexity.Mutation.RevokeRefreshToken == nil {
			break
		}

		args, err := ec.field_Mutation_revokeRefreshToken_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RevokeRefreshToken(childComplexity, args["tokenId"].(uuid.UUID)), true

	case "Mutation.verifyOTP":
		if e.complexity.Mutation.VerifyOtp == nil {
			break
		}

		args, err := ec.field_Mutation_verifyOTP_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.VerifyOtp(childComplexity, args["input"].(model.VerifyOTPInput)), true

	case "Query.getAllUsers":
		if e.complexity.Query.GetAllUsers == nil {
			break
		}

		return e.complexity.Query.GetAllUsers(childComplexity), true

	case "Query.getLatestOTP":
		if e.complexity.Query.GetLatestOtp == nil {
			break
		}

		args, err := ec.field_Query_getLatestOTP_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetLatestOtp(childComplexity, args["userId"].(uuid.UUID)), true

	case "Query.getSessionByUserId":
		if e.complexity.Query.GetSessionByUserID == nil {
			break
		}

		args, err := ec.field_Query_getSessionByUserId_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetSessionByUserID(childComplexity, args["userId"].(uuid.UUID)), true

	case "Query.getSessionStatus":
		if e.complexity.Query.GetSessionStatus == nil {
			break
		}

		args, err := ec.field_Query_getSessionStatus_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetSessionStatus(childComplexity, args["sessionId"].(uuid.UUID)), true

	case "Query.getUserById":
		if e.complexity.Query.GetUserByID == nil {
			break
		}

		args, err := ec.field_Query_getUserById_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUserByID(childComplexity, args["id"].(uuid.UUID)), true

	case "RefreshToken.createdAt":
		if e.complexity.RefreshToken.CreatedAt == nil {
			break
		}

		return e.complexity.RefreshToken.CreatedAt(childComplexity), true

	case "RefreshToken.expiresAt":
		if e.complexity.RefreshToken.ExpiresAt == nil {
			break
		}

		return e.complexity.RefreshToken.ExpiresAt(childComplexity), true

	case "RefreshToken.id":
		if e.complexity.RefreshToken.ID == nil {
			break
		}

		return e.complexity.RefreshToken.ID(childComplexity), true

	case "RefreshToken.ipAddress":
		if e.complexity.RefreshToken.IPAddress == nil {
			break
		}

		return e.complexity.RefreshToken.IPAddress(childComplexity), true

	case "RefreshToken.replacedBy":
		if e.complexity.RefreshToken.ReplacedBy == nil {
			break
		}

		return e.complexity.RefreshToken.ReplacedBy(childComplexity), true

	case "RefreshToken.revokedAt":
		if e.complexity.RefreshToken.RevokedAt == nil {
			break
		}

		return e.complexity.RefreshToken.RevokedAt(childComplexity), true

	case "RefreshToken.sessionId":
		if e.complexity.RefreshToken.SessionID == nil {
			break
		}

		return e.complexity.RefreshToken.SessionID(childComplexity), true

	case "RefreshToken.tokenHash":
		if e.complexity.RefreshToken.TokenHash == nil {
			break
		}

		return e.complexity.RefreshToken.TokenHash(childComplexity), true

	case "RefreshToken.userAgent":
		if e.complexity.RefreshToken.UserAgent == nil {
			break
		}

		return e.complexity.RefreshToken.UserAgent(childComplexity), true

	case "RefreshToken.userId":
		if e.complexity.RefreshToken.UserID == nil {
			break
		}

		return e.complexity.RefreshToken.UserID(childComplexity), true

	case "SessionStatus.user":
		if e.complexity.SessionStatus.User == nil {
			break
		}

		return e.complexity.SessionStatus.User(childComplexity), true

	case "SessionStatus.valid":
		if e.complexity.SessionStatus.Valid == nil {
			break
		}

		return e.complexity.SessionStatus.Valid(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.deletedAt":
		if e.complexity.User.DeletedAt == nil {
			break
		}

		return e.complexity.User.DeletedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.isActive":
		if e.complexity.User.IsActive == nil {
			break
		}

		return e.complexity.User.IsActive(childComplexity), true

	case "User.mobile":
		if e.complexity.User.Mobile == nil {
			break
		}

		return e.complexity.User.Mobile(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.password":
		if e.complexity.User.Password == nil {
			break
		}

		return e.complexity.User.Password(childComplexity), true

	case "User.role":
		if e.complexity.User.Role == nil {
			break
		}

		return e.complexity.User.Role(childComplexity), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	case "UserOTP.createdAt":
		if e.complexity.UserOTP.CreatedAt == nil {
			break
		}

		return e.complexity.UserOTP.CreatedAt(childComplexity), true

	case "UserOTP.expiresAt":
		if e.complexity.UserOTP.ExpiresAt == nil {
			break
		}

		return e.complexity.UserOTP.ExpiresAt(childComplexity), true

	case "UserOTP.id":
		if e.complexity.UserOTP.ID == nil {
			break
		}

		return e.complexity.UserOTP.ID(childComplexity), true

	case "UserOTP.isUsed":
		if e.complexity.UserOTP.IsUsed == nil {
			break
		}

		return e.complexity.UserOTP.IsUsed(childComplexity), true

	case "UserOTP.otpCode":
		if e.complexity.UserOTP.OtpCode == nil {
			break
		}

		return e.complexity.UserOTP.OtpCode(childComplexity), true

	case "UserOTP.userId":
		if e.complexity.UserOTP.UserID == nil {
			break
		}

		return e.complexity.UserOTP.UserID(childComplexity), true

	case "UserSession.createdAt":
		if e.complexity.UserSession.CreatedAt == nil {
			break
		}

		return e.complexity.UserSession.CreatedAt(childComplexity), true

	case "UserSession.expiresAt":
		if e.complexity.UserSession.ExpiresAt == nil {
			break
		}

		return e.complexity.UserSession.ExpiresAt(childComplexity), true

	case "UserSession.ipAddress":
		if e.complexity.UserSession.IpAddress == nil {
			break
		}

		return e.complexity.UserSession.IpAddress(childComplexity), true

	case "UserSession.revokedAt":
		if e.complexity.UserSession.RevokedAt == nil {
			break
		}

		return e.complexity.UserSession.RevokedAt(childComplexity), true

	case "UserSession.sessionId":
		if e.complexity.UserSession.SessionID == nil {
			break
		}

		return e.complexity.UserSession.SessionID(childComplexity), true

	case "UserSession.userAgent":
		if e.complexity.UserSession.UserAgent == nil {
			break
		}

		return e.complexity.UserSession.UserAgent(childComplexity), true

	case "UserSession.userId":
		if e.complexity.UserSession.UserID == nil {
			break
		}

		return e.complexity.UserSession.UserID(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateRefreshTokenInput,
		ec.unmarshalInputCreateUserInput,
		ec.unmarshalInputCreateUserOTPInput,
		ec.unmarshalInputCreateUserSessionInput,
		ec.unmarshalInputLoginInput,
		ec.unmarshalInputRefreshTokenInput,
		ec.unmarshalInputVerifyOTPInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/auth.graphqls", Input: `#---------------------------------
# User
#---------------------------------

type User {
  id: UUID!
  name: String!
  username: String!
  email: String!
  password: String!
  mobile: String!
  role: Int!
  isActive: Boolean!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: Time
}

input CreateUserInput {
  name: String!
  username: String!
  email: String!
  password: String!
  mobile: String!
  role: Int!
  isActive: Boolean!
}

#---------------------------------------------------------------
#OTP
#--------------------------------------------------------------

type UserOTP {
  id: UUID!
  userId: UUID!
  otpCode: String!
  expiresAt: Time!
  isUsed: Boolean!
  createdAt: Time!
}

input CreateUserOTPInput {
  userId: UUID!
  otpCode: String!
  expiresAt: Time!
}

#-------------------------------------------------------------
#Session
#------------------------------------------------------------

type UserSession {
  sessionId: UUID!
  userId: UUID!
  ipAddress: String!
  userAgent: String!
  createdAt: Time!
  expiresAt: Time!
  revokedAt: Time
}

input CreateUserSessionInput {
  userId: UUID!
  ipAddress: String!
  userAgent: String!
  expiresAt: Time!
}

# -------------------------------
# Refresh Token
# -------------------------------

type RefreshToken {
  id: UUID!
  userId: UUID!
  sessionId: UUID
  tokenHash: String!
  ipAddress: String
  userAgent: String
  createdAt: Time!
  expiresAt: Time!
  revokedAt: Time
  replacedBy: UUID
}

input CreateRefreshTokenInput {
  id: UUID!
  userId: UUID!
  sessionId: UUID
  tokenHash: String!
  ipAddress: String!
  userAgent: String!
  expiresAt: Time!
  revokedAt: Time
  replacedBy: UUID
}

type AuthPayload {
  accessToken: String
  refreshToken: String
  user: User
  sessionId: String
  userId:String
}

#--Login---------------------------------------

input LoginInput {
  email: String!
  password: String!
}

#--OTP------------------------------------------

input VerifyOTPInput {
  userId: UUID!
  otpCode: String!
}

#--Refresh Token----------------------------------

input RefreshTokenInput {
  sessionId: String!
}

type SessionStatus {
  valid: Boolean!
  user: User
}
`, BuiltIn: false},
	{Name: "../schema/schema.graphqls", Input: `scalar UUID
scalar Time

type Query {
  getUserById(id: UUID!): User
  getAllUsers: [User!]!
  getLatestOTP(userId: UUID!): UserOTP
  getSessionByUserId(userId: UUID!): UserSession
  getSessionStatus(sessionId:UUID!):SessionStatus
}

type Mutation {
  createUser(input: CreateUserInput!): User!
  createUserOTP(input: CreateUserOTPInput!): UserOTP!
  createUserSession(input: CreateUserSessionInput!): UserSession!
  createRefreshToken(input: CreateRefreshTokenInput!): RefreshToken!
  revokeRefreshToken(tokenId: UUID!): Boolean!


  login(input:LoginInput!):AuthPayload!
  verifyOTP(input:VerifyOTPInput!):AuthPayload!
  refreshToken(input:RefreshTokenInput!):AuthPayload!
  
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
